name: JD Jones CI/CD Pipeline

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]

env:
  # Environment variables common to all jobs
  PYTHON_VERSION: "3.11"
  POETRY_VERSION: "1.7.0"

jobs:
  # =================================================================================================
  # Lint & Unit Tests
  # Runs fast feedback loop: syntax checks and unit tests
  # =================================================================================================
  test:
    name: Lint & Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install ruff pytest httpx
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi

    - name: Lint with Ruff
      run: |
        # Stop the build if there are Python syntax errors or undefined names
        # E9, F63, F7, F82 are error codes for syntax errors
        ruff check . --select E9,F63,F7,F82 --show-source
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        ruff check . --exit-zero --statistics

    - name: Run Unit Tests
      run: |
        pytest tests/ -v

  # =================================================================================================
  #  Build & Integration Test
  # Builds Docker images and runs a smoke test against the container
  # =================================================================================================
  build-and-integration:
    name: Build & Integration
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create .env file from secrets
      run: |
        echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'postgres' }}" >> .env
        echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY || 'sk-dummy-token-for-ci' }}" >> .env
        echo "JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY || 'super-secret-jwt-key' }}" >> .env
        # Set dummy values for services not needed for build smoke test
        echo "ENVIRONMENT=ci" >> .env

    - name: Build Production Image
      # Verify that the production image builds successfully using the production compose file
      run: docker compose -f docker-compose.prod.yml build api

    - name: Build Test Stack
      # Build the stack for integration testing (using CI overrides for mocks)
      run: docker compose -f docker-compose.yml -f docker-compose.ci.yml build

    - name: Start Services (Integration Test)
      # Run the stack using CI overrides (lightweight, mocks) to verify application startup and logic
      run: docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d

    - name: Wait for API to be healthy
      # loop and wait for health check endpoint
      run: |
        timeout=60
        counter=0
        echo "Waiting for API to be healthy..."
        until curl -s http://localhost:8000/health > /dev/null; do
          if [ $counter -ge $timeout ]; then
            echo "Service failed to become healthy in $timeout seconds"
            docker compose -f docker-compose.yml -f docker-compose.ci.yml logs api
            exit 1
          fi
          printf '.'
          sleep 1
          counter=$((counter+1))
        done
        echo "API is healthy!"

    - name: Run API Smoke Test
      run: |
        curl -f http://localhost:8000/health
        curl -f http://localhost:8000/health/detailed || echo "/health/detailed failed (authenticated?)"

    - name: Tear down
      if: always()
      run: docker compose -f docker-compose.yml -f docker-compose.ci.yml down
